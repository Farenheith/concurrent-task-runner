"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mocha = require("mocha");
exports.testUtils = {
    prepare(service, prototype, methodToTest) {
        const backup = [];
        const subjects = exports.testUtils.getSubjects(prototype, service);
        const methods = exports.testUtils.getMockableMethods(subjects, service, methodToTest);
        exports.testUtils.createBackup(methods, backup, service);
        return backup;
    },
    getSubjects(prototype, service) {
        const subjects = [prototype];
        if (service !== prototype) {
            subjects.push(service);
        }
        return subjects;
    },
    getMockableMethods(subjects, service, methodToTest) {
        const methods = [];
        for (const subject of subjects) {
            exports.testUtils.getSubjectMockableMethods(subject, service, methodToTest, methods);
        }
        return methods;
    },
    getSubjectMockableMethods(subject, service, methodToTest, methods) {
        for (const key of Object.getOwnPropertyNames(subject)) {
            if (exports.testUtils.isMockable(key, subject, service, methodToTest)) {
                methods.push(key);
            }
        }
    },
    createBackup(methods, backup, service) {
        methods.forEach((m) => {
            backup.push([m, service[m]]);
            service[m] = exports.testUtils.getMockedMethod(m);
        });
    },
    mountStaticTest(cls, methodName, callback) {
        let backup;
        let target;
        mocha.beforeEach(() => {
            target = cls;
            backup = exports.testUtils.prepare(target, cls, methodName);
        });
        callback();
        mocha.afterEach(() => {
            exports.testUtils.restoreBackup(backup, target);
        });
    },
    mountInstanceTest(service, cls, methodName, callback) {
        let backup;
        let staticBackup;
        let target;
        mocha.beforeEach(() => {
            target = service();
            backup = exports.testUtils.prepare(target, cls.prototype, methodName);
            staticBackup = exports.testUtils.prepare(cls, cls);
        });
        callback();
        mocha.afterEach(() => {
            exports.testUtils.restoreBackup(backup, target);
            exports.testUtils.restoreBackup(staticBackup, cls);
        });
    },
    restoreBackup(backup, target) {
        for (const pair of backup) {
            target[pair[0]] = pair[1];
        }
    },
    isMockable(key, prototype, service, methodToTest) {
        return key !== methodToTest
            && typeof prototype[key] === 'function'
            // for instance methods
            && ((service !== prototype
                && key !== 'constructor'
            // for static classes
            ) || (service === prototype
                && key !== 'apply'
                && key !== 'bind'
                && key !== 'call'
                && key !== 'toString'));
    },
    getMockedMethod(name) {
        const result = eval(`(function ${name} () { throw new Error('${name} not mocked yet'); })`);
        return result;
    },
    setupFunction(transformer, mochaBase) {
        const result = transformer(mochaBase);
        result.skip = transformer(mochaBase.skip);
        result.only = transformer(mochaBase.only);
        return result;
    },
};
//# sourceMappingURL=test-utils.js.map